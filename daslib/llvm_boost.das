options indenting = 4
options no_unused_block_arguments = false
options no_unused_function_arguments = false

module llvm_boost shared

require llvm public

require daslib/safe_addr

def LLVMAddIncoming(phi:LLVMOpaqueValue?; var phi_vals:LLVMOpaqueValue? []; var phi_blocks:LLVMOpaqueBasicBlock? [])
    static_if typeinfo(dim phi_vals) != typeinfo(dim phi_blocks)
        concept_assert(false, "LLVMAddIncoming: phi_vals and phi_blocks must have the same length")
    LLVMAddIncoming(phi, unsafe(addr(phi_vals[0])), unsafe(addr(phi_blocks[0])), uint(length(phi_vals)))

def LLVMBuildGEP ( builder:LLVMOpaqueBuilder?; ptr:LLVMOpaqueValue?; var index:LLVMOpaqueValue?; name:string )
    return LLVMBuildGEP(builder, ptr, unsafe(addr(index)), 1u, name)

def LLVMBuildGEP2 ( builder:LLVMOpaqueBuilder?; ty:LLVMOpaqueType?; ptr:LLVMOpaqueValue?; var index:LLVMOpaqueValue?; name:string )
    return LLVMBuildGEP2(builder, ty, ptr, unsafe(addr(index)), 1u, name)

def LLVMFloat4Type
    return LLVMVectorType(LLVMFloatType(), 4u)

def LLVMFunctionType ( var ret_type:LLVMTypeRef; var param_types:LLVMTypeRef[]; isVariadic:bool = false )
    return LLVMFunctionType( ret_type, unsafe(addr(param_types[0])), uint(length(param_types)), isVariadic ? 1 : 0)

def LLVMFunctionType ( var ret_type:LLVMTypeRef; isVariadic:bool = false )
    return LLVMFunctionType( ret_type, null, 0u, isVariadic ? 1 : 0)

def LLVMVerifyModule(mod:LLVMOpaqueModule?; action:LLVMVerifierFailureAction; fail:bool=true)
    var error : string
    if LLVMVerifyModule(mod, action, safe_addr(error)) != 0
        if fail
            let msg = clone_string(error)
            LLVMDisposeMessage(error)
            panic(msg)
        else
            LLVMDisposeMessage(error)
        return false
    return true

def LLVMCreateJITCompilerForModule(var engine:LLVMExecutionEngineRef&; mod:LLVMOpaqueModule?; optlevel:uint=2u )
    var error : string
    if LLVMCreateJITCompilerForModule(unsafe(addr(engine)), mod, optlevel, safe_addr(error)) != 0
        let msg = clone_string(error)
        LLVMDisposeMessage(error)
        panic(msg)

def LLVMCreateExecutionEngineForModule(var engine:LLVMExecutionEngineRef&; mod:LLVMOpaqueModule? )
    var error : string
    if LLVMCreateExecutionEngineForModule(unsafe(addr(engine)), mod, safe_addr(error)) != 0
        let msg = clone_string(error)
        LLVMDisposeMessage(error)
        panic(msg)
