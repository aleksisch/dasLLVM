// this file is generated via daScript automatic C++ binder
// all user modifications will be lost after this file is re-generated

template <> struct cast_arg<_Lldiv_t> {
	static __forceinline const _Lldiv_t & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<_Lldiv_t *>::to(res);
	}
};
template <> struct cast_arg<LLVMOpInfoSymbol1> {
	static __forceinline const LLVMOpInfoSymbol1 & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOpInfoSymbol1 *>::to(res);
	}
};
template <> struct cast_arg<LLVMOpInfo1> {
	static __forceinline const LLVMOpInfo1 & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOpInfo1 *>::to(res);
	}
};
template <> struct cast_arg<LLVMMCJITCompilerOptions> {
	static __forceinline const LLVMMCJITCompilerOptions & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMMCJITCompilerOptions *>::to(res);
	}
};
template <> struct cast_arg<LLVMJITSymbolFlags> {
	static __forceinline const LLVMJITSymbolFlags & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMJITSymbolFlags *>::to(res);
	}
};
template <> struct cast_arg<LLVMJITEvaluatedSymbol> {
	static __forceinline const LLVMJITEvaluatedSymbol & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMJITEvaluatedSymbol *>::to(res);
	}
};
template <> struct cast_arg<LLVMOrcCSymbolFlagsMapPair> {
	static __forceinline const LLVMOrcCSymbolFlagsMapPair & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOrcCSymbolFlagsMapPair *>::to(res);
	}
};
template <> struct cast_arg<LLVMOrcCSymbolMapPair> {
	static __forceinline const LLVMOrcCSymbolMapPair & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOrcCSymbolMapPair *>::to(res);
	}
};
template <> struct cast_arg<LLVMOrcCSymbolAliasMapEntry> {
	static __forceinline const LLVMOrcCSymbolAliasMapEntry & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOrcCSymbolAliasMapEntry *>::to(res);
	}
};
template <> struct cast_arg<LLVMOrcCSymbolAliasMapPair> {
	static __forceinline const LLVMOrcCSymbolAliasMapPair & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOrcCSymbolAliasMapPair *>::to(res);
	}
};
template <> struct cast_arg<LLVMOrcCSymbolsList> {
	static __forceinline const LLVMOrcCSymbolsList & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOrcCSymbolsList *>::to(res);
	}
};
template <> struct cast_arg<LLVMOrcCDependenceMapPair> {
	static __forceinline const LLVMOrcCDependenceMapPair & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOrcCDependenceMapPair *>::to(res);
	}
};
template <> struct cast_arg<LLVMOrcCJITDylibSearchOrderElement> {
	static __forceinline const LLVMOrcCJITDylibSearchOrderElement & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOrcCJITDylibSearchOrderElement *>::to(res);
	}
};
template <> struct cast_arg<LLVMOrcCLookupSetElement> {
	static __forceinline const LLVMOrcCLookupSetElement & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LLVMOrcCLookupSetElement *>::to(res);
	}
};
template <> struct cast_arg<LTOObjectBuffer> {
	static __forceinline const LTOObjectBuffer & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<LTOObjectBuffer *>::to(res);
	}
};
